\section{Background}
\todo{combine server and client, use fully-malicious PIR \url{https://cypherpunks.ca/~iang/pubs/orpir-usenix.pdf} \url{https://eprint.iacr.org/2017/1142.pdf} -- just ignore malicious behavior}

\subsection{PRFs and OPRFs}
While there exist several different
PRFs~\cite{chaum,prf,dodis,ggm,lewko,bonehprf} and
OPRFs~\cite{oprf,stan,chase,koles,boneh,kia}, our exposition
introduces the DH-based candidates by \citet{prf} and \citet{oprf}, as
our constructions are build on their main idea.

Let $\myG$ be a group of prime order $p$ where the DDH assumption
holds, and $g$ is a random generator of $\myG$. For a security
parameter $\lambda$, we set $|p|=\lambda$.


\begin{construction}[\citeauthor{prf} PRF] \label{nrprf}
For any $\ell\in\N$, consider function family
$F_K(x):\myG^{\ell}\times\{0,1\}^\ell\rightarrow\myG$, where key $K$
is defined as a vector of $\ell+1$ random elements
$K=\vec{\alpha}=(\alpha_0,\ldots,\alpha_\ell)$.  For any $\ell$ bit input
$x=x_1 \ldots x_\ell$, function $F_K$ is
defined by
 $$F_K(x) = (g^{\alpha_0})^{\prod_{x_i=1}\alpha_i}.$$

\ignore{
  Define the function ensemble $F = \{F_n\}_{n\in N}$.  For every $n$, a key of a function $F_n$ is a tuple, $\langle P,Q,g,\vec{\alpha}\rangle$, 
where $P$ is an $n$-bit prime, $Q$ a prime divisor of $P-1$, $g$ an element of order $Q$ in $\mathbb{Z}_{p}^*$ and $\vec{\alpha}=\langle 
\alpha_0,\alpha_1, \ldots , \alpha_n \rangle$ a uniformly random sequence of $n+1$ elements of $\mathbb{Z}_Q$.  For any $n$-bit input, $x=x_1 x_2 \ldots x_n$, the 
function $f_{P,Q,g,\vec{\alpha}}$ is defined by:
 $$f_{P,Q,g,\vec{\alpha}}(x) = (g^{\alpha_0})^{\prod_{x_i=1}\alpha_i}$$
}%ignore
\end{construction}

\begin{theorem}[Theorem~4.1 of~\cite{prf}]
\label{theorem:naor}
If the DDH-Assumption holds, then for every PPT distinguisher
$\mathcal{D}$, there exists a negligible function $\epsilon$ such that for
    sufficiently large $\lambda$
$$| Pr[\mathcal{D}^{F_K}=1] - Pr[\mathcal{D}^{R} = 1]|
    =\epsilon(\lambda), $$ where $K$ is chosen randomly as in
    Construction~\ref{nrprf}, and $R$ is a randomly chosen function
    from the set of functions with domain $\{0,1\}^\ell$ and image
    $\myG$.

\ignore{
If the DDH-Assumption holds, then for every probabilistic polynomial-time oracle machine $\mathcal{M}$, every constant $\gamma > 0$, and for all but a finite number of $n$'s
$$| Pr[\mathcal{M}^{f_{P,Q,g,\vec{\alpha}}}(P,Q,g)=1] - Pr[\mathcal{M}^{R_{P,Q,g}}(P,Q,g) = 1]| < \frac{1}{n^\gamma} $$
where in the first probability, $f_{P,Q,g,\vec{\alpha}}$ is distributed according to $F_n$, and in the second probability the distribution of $R_{P,Q,g}$ is uniformly chosen in the set of functions with the domain $\{0,1\}^n$ and image $\langle g\rangle$.
}%ignore
\end{theorem}

\begin{construction}[OPRF$_K(x)$ from~\cite{oprf}]
\label{ot-oprf}
  During initialization, sender $S$ chooses key
  $K=(\alpha_0,\ldots,\alpha_\ell)$ by randomly sampling $\ell+1$
  scalars $\alpha_i\getr\Z_p$.

  To evaluate receiver $R$'s input $x=(x_1\ldots{}x_\ell)$, parties perform the following steps.
  \begin{enumerate}
  \item $S$ randomly selects $(r_1,\ldots,r_\ell),r_i\getr\Z_p$.
  \item $S$ and $R$ engage in $\ell$ rounds of $\binom{2}{1}$-OT. In round
    $i$, the server's input to OT is $(r_i,r_i\cdot\alpha_i)$, and the
    receiver's input is $x_i$. So, depending on $x_i$, the receiver gets either $z_i=r_i$ or $z_i=r_i\cdot{}\alpha_i$.
  \item $S$ sends $\hat{g}=g^{\frac{1}{\prod_{i=1}^{\ell}r_i}}$ to $R$.
    \item $R$ outputs $\text{OPRF}_K(x)=\hat{g}^{\prod^{\ell}_{i=1}z_i}$.
    
    \end{enumerate}
\end{construction}

\citet{oprf} present a sketch for a proof of
Construction~\ref{ot-oprf}. Essentially, this OPRF assembles the
\citeauthor{prf} function $F_K$ on input $x$ in $\ell$ rounds.  So, if
the DDH assumptions holds, and if the underlying OT is secure and
neither leaks $r_i$ and $r_i\cdot\alpha_i$ at the same time, then
Construction~\ref{ot-oprf} is a secure OPRF (in the semi-honest
model).

NOTE: for one-sided security, we use the OT-based solution.

\subsection{New $\iprf$ and $\ioprf$ Definition}

\subsubsection{iPRF}
\begin{definition}[$\iprf$]\label{defiprf}
  For inputs $x=(x_1\ldots{}x_\ell)\in\{0,1\}^\ell$ and randomly
  chosen keys $K=(K_1,\ldots,K_\ell)\in\{0,1\}^{\ell\cdot\lambda}$, an
  iterated pseudo-random function family $\iprf_K$ is a sequence
  $f_K(x)$ of function families
  $f_K(x)=(f^1_{K_1}(x_{1}),\ldots,f^\ell_{K_1,\ldots,K_\ell}(x_{1}\ldots{}x_{\ell}))$,
  where each
  $f^i_{K_1,\ldots,K_i}(x_{1}\ldots{}x_{i}):\{0,1\}^{i\cdot\lambda}\times\{0,1\}^{i}\rightarrow{}\{0,1\}^\lambda$
  is a pseudo-random function family with key $(K_1,\ldots,K_i)$ from
  $K$ and input $(x_1\ldots{}x_i)$ from $x$. Concatenated output
  $V_\lambda=v_1||\ldots||v_\ell,v_i=f^i_{K_1,\ldots,K_i}(x_1\ldots{}x_i)$
  is a family of random variables (a probability ensemble) of bit
  strings of length $\ell\cdot\lambda$.

\ignore{ We call $f_K(x)$ an iterated pseudo-random function family
  $\iprf_K$ \emph{iff} for all PPT adversaries $\A$, all
  $(x_1,\ldots,x_\ell)\in\{0,1\}^\ell$, and randomly chosen $K$ there
  exists a negligible function $\epsilon$ such that for sufficiently
  large $\lambda$
\begin{align*}\forall{}i\in\{1,\ldots,\ell\}:|&Pr[(v_1,\ldots,v_\ell)\leftarrow{}V_\lambda:\A(v_1,\ldots,v_i)=1]-\\&Pr[(v_1,\ldots,v_\ell)\leftarrow{}V_\lambda,u\leftarrow{}U_\lambda:\A(v_1,\ldots,v_{i-1},u)=1]|\\&=\epsilon(\lambda),
  \end{align*}
  where $U_\lambda$ is the random variable describing uniformly random
  bit strings of length $\lambda$. The probabilities are taken over
  the random coins of $\A$ and $K$.}
\end{definition}

Definition~\ref{defiprf} implies that each probability ensemble
$v_i=\{(v_i)_\lambda\}_{\lambda\in\N}$ of length $\lambda$ bit strings
is computationally indistinguishable from an ensemble $u_i$ describing
uniformly random bit strings of length $\lambda$. However, probability
ensemble $V_\lambda=v_1||\ldots||v_\ell$ is \emph{not}
indistinguishable from ensemble $U_{\lambda,\ell}$ of uniformly random
bit strings of length $\lambda\cdot\ell$. Instead, if any two inputs
$x$ and $x'$ share the same prefix of length $i$, then the first $i$
outputs $(v_1,\ldots,v_i)$ of $\iprf(x)$ will equal those of
$\iprf(x')$.  \fixme{This is the important property we need to
  traverse a tree blabla...}

\paragraph{Strawman Constructions}
Observe that the \citeauthor{prf} PRF $F_K$ from
Construction~\ref{nrprf} is not an $\iprf$ and cannot easily be
converted into an $\iprf$. First, to support $\lambda\cdot\ell$
outputs, $\lambda$ for each input bit $x_i$, one might try and create
an $\iprf$ out of
$(F_{K_1}(x_1),\ldots,F_{K_1,\ldots,K_\ell}(x_1\ldots{}x_\ell))$,
where $K_1=\alpha_1,\ldots,K_\ell=\alpha_\ell$.  However, this is in
fact not an $\iprf$, as exemplified by inputs like
$x=(10\ldots{}0)$. There, we have
$F_{K_1}(1)=F_{K_1,K_2}(10)=\ldots=F_{K_1,\ldots,K_\ell}(10\ldots{}0)$,
so the output repeats starting from the $2^\text{nd}$ invocation of
$F$. In general, for any input $x=\mathsf{PREFIX}||0\ldots{}0$ ending
with a sequence of zeros, $F_K(x)$ will be equal to
$F_K(\mathsf{PREFIX})$ in violation of Definition~\ref{defiprf}.

A simple real-world construction for an $\iprf$ could be based on
variable input length PRFs such as HMAC and a collision resistant hash
function $H$. For example, consider
$\iprf_K(x)=(\hmac_{H(K_1)}(x_1),\ldots,\hmac_{H(K_1||\ldots||K_\ell)}(x_1\ldots{}x_\ell))$.
While this HMAC-based construction and probably also adoptions of
others PRFs like PRG-based PRFs~\cite{ggm} might result in valid
$\iprf$s, we dismiss them in favor of our new
Construction~\ref{const:newprf} (Section $\S$\ref{sec:newprf}). This
constructions offers several advantages: first, it builds on the
\citeauthor{prf} PRF which allows an elegant, formal security
reduction from DDH to our construction. More importantly, its key
advantage is that you can use it as a building block to construct an
$\ioprf$ which moreover supports, delegation, verifiability, and
malicious security as we will see below.

\subsubsection{iOPRF}
\begin{figure}[tb]
\RestyleAlgo{boxed}
\LinesNumbered
\begingroup
\removelatexerror% Nullify \@latex@error
\begin{functionality}[H]
  \tcp{Let $\iprf$ be an iterated pseudo-random function family}
  $S\rightarrow{}\fioprf$: $K$\; \For{$i=1$ {\bf to} {$\ell$} }{
    $R\rightarrow{}\fioprf:x_i$\; $\fioprf\rightarrow{}R: v_i$ such
    that $(v_1,\ldots,v_\ell)=\iprf_K(x_1\ldots{}x_\ell)$\; }
\end{functionality}
\endgroup
\caption{Functionality $\fioprf$\label{idealioprf}}
\end{figure}

\begin{definition}[$\proto$]
  Let $\iprf_K$ be an iterated pseudo-random function family.  An
  iterated \emph{oblivious} pseudo-random function is an $\ell$-round
  probabilistic protocol $\proto$ between a sender $S$ with input key
  $K\in\{0,1\}^{\lambda\cdot\ell}$ and receiver $R$ with input bit
  string $x=(x_1\ldots{}x_\ell)\in\{0,1\}^{\ell}$ with the following
  properties.

  \begin{itemize}
   
  \item Protocol $\proto$ realizes the ideal functionality $\fioprf$
    shown in Figure~\ref{idealioprf}. This is a reactive functionality
    allowing queries from $R$ in a total of $\ell$ rounds.  After
    $\ell$ rounds, $R$ has received
    $(v_1,\ldots,v_\ell)=\iprf_K(x),|v_i|=\lambda$, from
    $\fioprf$. Sender $S$ receives nothing from $\fioprf$.
  
  \item For all adversaries $\A$ in the real world, there exists a
    simulator $\myS_R$ in the ideal world such that $R$'s view
    $\mathsf{REAL}_{\proto,\A,R}(x,K)$ in the real world is
    computationally indistinguishable from $R$'s view
    $\mathsf{IDEAL}_{\fioprf,\myS_R(x)}(x,K)$ in the ideal world.

  \item For all adversaries $\A$ in the real world, there exists a
    simulator $\myS_S$ in the ideal world such that $S$'s view
    $\mathsf{REAL}_{\proto,\A,S}(K)$ in the real world is
    computationally indistinguishable from $S$'s view
    $\mathsf{IDEAL}_{\fioprf,\myS_S}(K)$ in the ideal world.
\end{itemize}
\end{definition}

The crucial difference of $\ioprf$s in contrast to regular
$\oprf$s~\cite{oprf,stan,chase,koles,boneh,kia} is that at the end of
the protocol execution, $R$ has received not one but $\ell$ PRF values
$v_i$ with $(v_1,\ldots,v_\ell)=\iprf(x)$. For two inputs $x$ and $x'$
with the same length $i$ bit prefix, values $v_1,\ldots,v_i$ will be
the same. Note that receiver $R$ can specify their input adaptively
during $\ell$ rounds. Before sending $x_i$, $R$ has learned $v_{i-1}$
from $\fioprf$. Still, $R$ receives output strings matching an
$\iprf$, so they cannot combine outputs from different $\ioprf$
executions with different input. For example, knowledge of
$\ioprf_K(10\ldots)$ and $\ioprf_K(01\ldots)$ should not allow $R$ to
learn anything about $\ioprf_K(11\ldots)$.  Against a fully-malicious
receiver, this cannot be accomplished easily with regular OPRFs.  One
might try and run $\ell$ instances of the OPRF, but the challenge is
that one would have to force $R$ to link their input during the
$i^\text{th}$ instance of the OPRF to the $(i-1)^\text{th}$ instance.
Our $\ioprf$ in Section~\S\ref{our-ioprf} offers a solution to this
challenge.

\paragraph{Verifiability}
An important aspect of OPRFs which we also require for $\ioprf$s is
that of \emph{verifiablity}, see \citet{kia} for technical
details. Essentially, verifiablity implies that $S$ proves to $R$ that
$R$'s output $(v_1,\ldots,v_\ell$ has been computed correctly. Towards
providing malicious security, verifiability is especially important
when the $\ioprf$ is run multiple times, and $S$ could cheat by using
different keys for different protocol runs.

We refer to \cite{kia} for a treatment with more formal definitions in
the context of OPRFs which also hold for $\ioprf$s.  For our
constructions, we are going to simply prove that $R$'s output has been
correctly computed by using a key which $S$ has been committed to
before.

Observe that the original OPRF from Construction~\ref{ot-oprf} is not
maliciously secure and thus does not offer verifiablity. Even if OT as
a building block would be secure against a malicious adversary, it is
unclear how to verify that the sender has used the same key $K$ for
different OPRF protocol runs.

\subsubsection{Delegation for $\iprf$s and $\ioprf$s}
Informally, a PRF $F$ with domain $\D$ is delegatable, if for some
subset $D'\subset\D$ you can (efficiently) compute a sub-key $K'$ from
key $K$ and another PRF $F'$ from $F$, such that $F'_{K'}$ equals
$F_K$ on all $x\in\D$, but is random everywhere else. There exists a
rich theory on delegatable PRFs, see \citet{delegate} for details.

In the context of $\iprf$s, we are particularly interested in
delegating iterated PRF computation for strings
$x=(x_1\ldots{}x_\ell)$ sharing the same fixed prefix. That is, a
party $P_1$ knowing key $K$ specifies a prefix
$x^*=(x^*_1\ldots{}x^*_i)$, computes $K'$ and $\iprf'$, and gives
$(\iprf',K')$ to party $P_2$. Party $P_2$ is then capable of computing
$\iprf_K(x)$ for all bit strings $x$ having the same prefix $x^*$. At
the same time, knowledge of $K'$ does not help $P_2$ in
distinguishing bit strings $x$ with different prefixes from from the
output of $\iprf_{\hat{K}}(x)$ for any other random key $\hat{K}$.  We
formalize this intuition in Definition~\ref{def:del}.

\begin{definition} \label{def:del}
  Let $\iprf$ be an iterated pseudo-random function on length $\ell$
  bit input strings with random key $K$.  We call an $\iprf$
  \emph{delegatable}, \emph{iff}
  \begin{enumerate}
    \item
  There exists a PPT transformation
  algorithm $T$, which on input $(\iprf,K,x^*_1\ldots{}x^*_i)$ outputs
  $(\iprf',K')$, where
  $\iprf':\{0,1\}^{\lambda\cdot(\ell-i)}\times\{0,1\}^{\ell-i}\rightarrow{}\{0,1\}^{\lambda\cdot(\ell-i)}$
  and
    $\forall{}x'=(x'_1\ldots{}x'_{\ell-i}):\iprf'_{K'}(x')=\iprf_{K}(x^*_1\ldots{}x^*_ix'_1\ldots{}x'_{\ell-i})$.
  \item For all PPT adversaries $\A$ and randomly chosen $K$,
    there exists a negligible function $\epsilon$ such that for
    sufficiently large $\lambda$ we have

    \begin{align*}
      &\forall{}x=(x_1\ldots{}x_\ell),x_1\ldots{}x_i\neq{}x^*_1\ldots{}x^*_i:\\&|Pr[\hat{K}=(\hat{K}_1,\ldots,\hat{K}_\ell)\getr\{0,1\}^{\lambda\cdot\ell},(v_1,\ldots,v_\ell)=\iprf_K(x),\\&(\hat{v}_1,\ldots,\hat{v}_\ell)=\iprf_{\hat{K}}(x):\A(\iprf',K',(\hat{v}_1,\ldots,\hat{v}_i,v_{i+1},\ldots,v_\ell))]\\-&Pr[\A(\iprf',K',v_1,\ldots,v_\ell)=1]|=\epsilon(\lambda).
\end{align*}
    \end{enumerate}
  \end{definition}

Along the same lines, a \emph{delegatable} $\ioprf$ is an $\ioprf$
where the underlying $\iprf$ supports delegation. 

\paragraph{Discussion}
Note that knowledge of $K'$ and the first $i$ values of the output
$(v_i,\ldots,v_i)$ of $\iprf_K(x)$ does permit $P_2$ to enumerte all
suffixes of strings $x$ which share the same length $i$ prefix as
$x$. At first, this property might look like a severe restriction to
the value of this type of delegation, but we will show in
Section~\ref{sec:applications} that it has still interesting
real-world applications.

We implicitly require non-triviality (bandwidth
efficiency~\cite{delegate}) of delegation. For example, $P_1$ could
delegate the capability to evaluate all strings with prefix $x^*$ by
simply computing $\iprf_K(x)$ for all strings $x$ with prefix $x^*$
and sending the output to $P_2$. So, tuple $(\iprf',K')$ should be
smaller in size than the concatenation of all strings with prefix
$x^*$.

Finally, we point out that delegation can be extended from $\iprf$s to
$\ioprf$s in the natural way. If $P_1$ gives $(\iprf',K')$ to $P_2$,
then $P_2$ is also able to run a 2-party protocol with another party
$P_3$, where $P_3$ correctly receives
$\ioprf'_{K'}(x')=\iprf'_{K'}(x')$ for input $x'$ with prefix $x^*$
while $P_2$ learns nothing about $x'$.


