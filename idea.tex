\documentclass{article}

\input{macros}

\begin{document}
NOTE: for one-sided security, we use the OT-based solution.

\begin{definition}[$\iprf$]
  Consider function family
  $f_K(b_1,\ldots,b_\ell):\{0,1\}^{\lambda\cdot\ell}\times\{0,1\}^{\ell}\rightarrow{}(v_1,\ldots,v_\ell)\in\{0,1\}^{\lambda\cdot\ell}$. For a
  randomly chosen key $K$, observe that range
  $V_\lambda=(v_1,\ldots,v_\ell)$ is a family of random variables (a
  probability ensemble) of length $\ell\cdot\lambda$ bit strings. We
  call function $f_K$ an iterated pseudo-random function family
  $(\iprf_K)$ \emph{iff} for all adversaries $\A$ and for all
  $(b_1,\ldots,b_\ell)\in\{0,1\}^\ell$ there exists a negligible
  function $\epsilon$ such that for sufficiently large $\lambda$
\begin{align*}\forall{}i\in\{1,\ldots,\ell\}:|&Pr[(v_1,\ldots,v_\ell)\leftarrow{}V_\lambda:\A(v_1,\ldots,v_i)=1]-\\&Pr[(v_1,\ldots,v_\ell)\leftarrow{}V_\lambda,u\leftarrow{}U_\lambda:\A(v_1,\ldots,v_{i-1},u)=1]|\\&=\epsilon(\lambda),
  \end{align*}
  where $U_\lambda$ is the random variable describing uniformly random
  bit strings of length $\lambda$. The probabilities are taken over
  the random coins of $\A$ and $K$.

\end{definition}

\begin{definition}[$\proto$]
  Let $\iprf_K$ be an iterated pseudo-random function family.  An
  iterated \emph{oblivious} pseudo-random function is a probabilistic
  protocol $\proto$ between a sender $S$ with input key
  $K\in\{0,1\}^{\lambda\cdot\ell}$ and receiver $R$ with input bits
  $(b_1,\ldots,b_\ell)\in\{0,1\}^{\ell}$ with the following
  properties.

  \begin{itemize}
   
\item Protocol $\proto$ realizes the ideal functionality $\iprf$. It
  outputs
  $(v_1,\ldots,v_\ell)=\iprf_K(b_1,\ldots,b_\ell),|v_i|=\lambda$, to
  $R$ and nothing to $S$.
  
\item For all adversaries $\A$ in the real world, there exists a
  simulator $\myS_R$ in the ideal world such $R$'s view
  $\mathsf{REAL}_{\proto,\A,R}(b_1,\ldots,b_\ell,K)$ in the real world is
  computationally indistinguishable from $R$'s view
  $\mathsf{IDEAL}_{\iprf,\myS_R(b_1,\ldots,b_\ell)}(b_1,\ldots,b_\ell,K)$ in
  the ideal world.

\item
   For all adversaries $\A$ in the real world, there exists a
  simulator $\myS_S$ in the ideal world such $S$'s view
  $\mathsf{REAL}_{\proto,\A,S}(b_1,\ldots,b_\ell,K)$ in the real world is
  computationally indistinguishable from $S$'s view
  $\mathsf{IDEAL}_{\iprf,\myS_S}(b_1,\ldots,b_\ell,K)$ in
  the ideal world.  
\end{itemize}
\end{definition}


\section{Our function $\iprf$}
Let $q$ be the order of the group in which we operate (e.g., points of
an elliptic curve with point addition), and $G$ is a random generator.

Initialization: choose a key $K=(\vec{{r}},\vec{s})$ by sampling $\ell$ pairs of random scalars ${r_{i}}\getr\Z^*_q,{s_{i}}\getr\Z^*_q.$

$\iprf(b_1,\ldots,b_\ell)$: output a vector $\vec{v}$ of length $\ell$ where $v_i = G \cdot \prod_{j=1}^{i} r_j^{b_j}s_j^{1-b_j}$
%$({r_1^{b_1}}\cdot{}G,\ldots,{r_1^{b_1}\cdots{}r_\ell^{b_\ell}}\cdot{}G)$

\todo{Show that this is a PRF}

\section{Our $\proto$}

The $\iprf$ above can be computed as an oblivious PRF between a sender $S$ and a receiver $R$.  In this protocol,
the receiver $R$ has an array of bits $(b_1, \ldots, b_\ell)$ and wishes to compute $\iprf(b_1, \ldots, b_\ell)$ using
the key $K$ possessed by $S$.

Let $\ot(b, y_0, y_1)$ denote a secure 1-out-of-2 oblivious transfer protocol between $R$ and $S$ where
S holds $y_0$ and $y_1$, and $R$ obliviously retrieves $y_b$ from $S$.  

\begin{itemize}
\item $S$ generates $\ell$ random scalars $a_i\getr\Z^*_q$
\item For each $1 \leq i \leq \ell$, $R$ and $S$ execute $\ot(b_i, a_ir_i, a_is_i)$ and stores the result as $z_i$
\item $S$ sends to $R$ the vector $\vec{C}$ where $\forall 1 \leq i \leq \ell$, $C_i =  G \cdot \frac{1}{\prod_{j=1}^{i} a_j}$
\item $R$ recovers $\iprf$ output vector $v$ by calculating $v_i = C_i \cdot \prod_{j=1}^{i} z_j$
\end{itemize}

{\bf Corectness:} For all $1 \leq i \leq \ell$ we have
\begin{equation}
\begin{aligned}
v_i &= C_i \cdot \prod_{j=1}^{i} z_i \\
&= G \cdot \frac{1}{\prod_{j=1}^{i} a_j} \cdot \prod_{j=1}^{i} z_j \\
&= G \cdot \frac{1}{\prod_{j=1}^{i} a_j} \cdot \prod_{j=1}^{i} (a_jr_j)^{b_j}(a_js_j)^{1-b_j} a_j \\
&= G \cdot \prod_{j=1}^{i} r_j^{b_j}s_j^{1-b_j}
\end{aligned}
\end{equation}

\todo{Show that this is an OPRF. And show that the iterative evaluation is still secure.}



\section{Difference to structured encryption}
\begin{itemize}
\item Different adversary model
\item Matrix queries and labeled data queries, neighbor queries and adjacency queries on graphs, are trivial.
\item Token length?!
\item the original PRF is mentioned by Naor and Reingold (Section 6.3), but details on how to use OT is mentioned by \url{https://www.iacr.org/archive/tcc2005/3378_304/3378_304.pdf}.  
\end{itemize}

\ignore{
* Note that our iOPRF can be evaluated ``interactively'',  i.e., the receiver runs OTs adaptively

Motivation:

* One could just replace the PRF in structured encryption (Figure 2 /
Section 5) with an OPRF, but this is not sufficient: the adversary
could ``flip-flop'' inside the graph, but we want that they can only
follow paths.


Apps:
* Graphs: https://robobees.seas.harvard.edu/files/privacytools/files/grecs.pdf
and https://par.nsf.gov/servlets/purl/10042572 and http://www.vldb.org/pvldb/vol11/p420-sahu.pdf

* Similar as with structured encryption (web graphs, graphs, matrices)

* What about running SQL queries https://eprint.iacr.org/2016/453.pdf

* We also allow for ``controlled disclosure'', e.g., the server
reveals one internal node, the root of some subtree, and the client
can then go on and make queries on that subtree. 

https://www.cis.upenn.edu/~mkearns/papers/nwlocal.pdf
Jump and crawl algorithms for analyzing social networks

* Microsoft Azure Marketplace: allow a cloud application to analyze your data.
** Data provider does not want to reveal whole data set, but only ``subtree''
** Cloud Application does not want to leak details about their techniques 
*** Compromise between no security and fully-homomorphic encryption or MPC

* HITS and PageRank: algorithms to analyze properties of an intranet, local sub-tree of the intranet

}

\ignore{
\newpage

\section{Old}
\paragraph{Preliminaries} There are two parties $P_1$ and $P_2$ with
input sets $S_1=\{e_{1,1},\ldots,e_{1,n}\}$ and
$S_2=\{e_{2,1},\ldots,e_{2,n}\}$ of elements
$e_{i,j}\in\{0,1\}^\ell$. Both parties have agreed on an Elgamal key
pair $(pk,sk)$ where $sk$ is shared between the two of them.

For security parameter $\lambda$, there exists an oblivious
pseudo-random function
$\oprf:\{0,1\}^\lambda\times\{0,1\}^\ell\rightarrow{}\{0,1\}^\ell$.
In our context, $\oprf$ will be evaluated with $P_1$ being the sender
and $P_2$ being the receiver.

\paragraph{Protocol Overview}
\begin{enumerate}[label={\bf Step {\arabic*}:},leftmargin=*]
\item Party $P_1$ prepares a binary prefix tree of its input set as follows.

  First, $P_1$ generates a random key $k\getr\{0,1\}^\lambda$ for $\oprf$.

  For each $e_{1,i}\in{}S_1$, $P_1$ computes $V_i=\oprf_k(e_{1,i})$
  and builds a prefix tree $T$ with the $V_i$ as keys. Observe that
  each node $N_i$ in $T$ contains tuple
  $(\mathsf{prefix}_i,\mathsf{L}_i,\mathsf{R}_i)$, where
  $\mathsf{prefix}_i$ is node $N_i$'s bit string prefix, and
  $\mathsf{L}_i$ and $\mathsf{R}_i$ are pointers to the $N_i$'s left
  and right children and can therefore be $\bot$.

  $P_1$ stores $T$ in an array $A$, so pointers $\mathsf{L}_i$ and
  $\mathsf{R}_i$ are indices of $A$'s elements. Let the number
  of nodes in $T$ and therewith the number of elements in $A$ be
  $n'$.

  \fixme{Why would $P_1$ have to shuffle $T$?}
  
  Finally, $P_1$ Elgamal encrypts each element $N_i$ of array $A$ to
  $c_i=(\enc_{pk}(\mathsf{prefix}_i),\enc_{pk}(\mathsf{L}_i),\enc_{pk}(\mathsf{R}_i))$
  and sends the $c_i$ to $P_2$.

\item $P_2$ re-encrypts array $A$, i.e., all $c_i$ to $c'_i$, chooses
  a random permutation $\pi:\{1,\ldots,n\}\rightarrow\{1,\ldots,n\}$
  and randomly shuffles the $c'_i$ with $\pi$. Party $P_2$ sends
  resulting array $A'$, the sequence of $c'_{\pi(i)}$, back to $P_1$.

\item For each $e_{2,i}\in{}S_2$, $P_1$ and $P_2$ jointly evaluate
  $\oprf$ such that $P_2$ learns $v'_i=\oprf_k(e_{2,i})$, and $P_1$
  learns nothing.

\item Let $v'_i=b_{i,1}\ldots{}b_{i,\ell}$ be the bit representation
  of $v'_i$. Party $P_2$ fetches data from $P_1$ as follows.

  Party $P_2$ asks $P_1$ to partially decrypt element $\pi(0)$, the
  root, from $A'$. Upon receipt, $P_2$ finalizes decryption of
  $\pi(0)$ to $(\mathsf{prefix},\mathsf{L},\mathsf{R})$.

  They then use bit $b_{i,1}$ to either set
  ${\mathsf{next}}=\mathsf{L}$ or ${\mathsf{next}}=\mathsf{R}$, fetch
  the partial decryption of $\pi({\mathsf{next}})$ from $A'$ and so on.

  Note that $P_2$ never fetches the same element from $A'$ twice. 
  
\end{enumerate}

\fixme{Optimization: do not send back the shuffled array...}

\section{Related Work}
\begin{itemize}
\item Katzenbeisser: \url{https://dl.acm.org/doi/pdf/10.1145/1315245.1315309}:
  privacy-preserving evaluation of a FSM, semi-honest, number of
  states (and therewith this scheme's communication complexity) of the
  FSM is exponential in the edit distance:
  \url{https://store.fmi.uni-sofia.bg/fmi/logic/theses/mitankin-en.pdf}
\item Kerschbaum: \url{http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.584.3879&rep=rep1&type=pdf}, semi-honest, $\ell^2$ per item
\end{itemize}
}%ignore
  \end{document}
