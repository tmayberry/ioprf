\section{Introduction}
Structured encryption allows a data owner to encrypt structured data,
and outsource it to an untrusted server.  They crucial property of
structured encryption is that the data owner can later compute a
special decryption key for the server which permits the server to
decrypt and parse a well defined component of the data structure.  A
typical example for structured data is data arranged in a graph, and
the owner computes keys for decryption of sub-graphs.  Computation of
decryption keys is possible despite the owner retaining only a
constant-sized master key.

In this paper, we introduce a twist to the standard setting of
structured encryption. Another party, the client, can ask the data
owner to compute a key to decrypt a specific component of the owner's
data structure. Yet, data owner and client are mutually
untrusted. That is, the client does not want to reveal to the
(potentially) fully-malicious owner which component of the data
structure the client is interested in. The owner wants to prepare a
decryption key which confines the (potentially) fully-malicious client
to decrypting only data from one component of the data
structure. Using the decryption key, the client then fetches the
component of the data structure they are interested in from the server
and decrypts it. In case the client does not trust the server, the
client reverts to standard techniques such as PIR to fetch data from
the server.

We focus only on directed acyclic graph data structures, i.e., trees,
but in return offer more powerful confinement control than structured
encryption for the data owner.  In addition to decryption keys
enabling decryption of a sub-tree for the client, the data owner can
also compute keys which enable the client to access only one path,
from the root of the tree to a leaf.  Moreover, the client can ask to
decrypt a path in an iterative, adaptive fashion instead of querying
the owner at once.  That is, the client will parse the tree node by
node, obliviously asking the owner to decrypt the next node in the
tree only after fetching and decrypting the previous node.  For
example, after decrypting one node of a binary tree, the client can
obliviously query the owner for the decryption key of either the left
or right child, depending on the current node's data content.  At the
same time, the data owner wants to ensure that the client can only ask
to decrypt a node which is a child of the current node, such that the
client is confined to decrypting exactly one path and cannot
arbitrarily ``jump around'' in the data structure.  We will see later
that our new setting of structured encryption for trees with an
untrusted client has several interesting real-world applications.

Yet, enabling this new scenario turns out to be technically
challenging.  A straightforward, intuitive approach might be for the
owner to apply an Oblivious Pseudo-Random Function (OPRF) as the PRF
to encrypt nodes. For a tree of height $\ell$, owner and client then
run $\ell$ instances of the OPRF such that the client always learns
the key for the next node on the path they are interested in, and the
owner learns nothing. However, this approach is only secure against
semi-honest clients which stick to the rule of asking for the
decryption key of one child node of the current node. The difficulty
lies in making parsing the tree structure secure against a
fully-malicious client without reverting to general, yet expensive
techniques such as maliciously secure two-party computation and
expensive general Zero-Knowledge Proofs.

Consequently, we introduce the notion of iterated Oblivious
Pseudo-Random Functions ($\ioprf$s) and introduce candidate
constructions. An $\ioprf$ is an $\ell$ round two party protocol
between a sender and a receiver. Its definition captures the intuition
that the receiver can adaptively query $\ell$ input bits $x_i$ in
$\ell$ rounds such that in the end they learn outputs
$\text{PRF}_K(x_1),\ldots,\text{PRF}_K(x_1\ldots{}x_\ell)$ for key $K$
chosen by the sender, and the sender learns nothing.

Our $\ioprf$ construction is based on a careful adoption of the PRF by
\citet{prf}. We first augment the \citeauthor{prf} PRF to become an
iterated Pseudo-Random Function ($\iprf$) which has the property that,
for input strings with the same prefix, its generated output also
shares the same prefix. We then use the same trick as \citet{oprf} to
convert the $\iprf$ to an $\ioprf$. This first $\ioprf$ is OT-based
and thus very efficient, yet it only offers one-sided security with a
malicious receiver and semi-honest sender. We then present our main
construction, an $\ioprf$ which is secure against malicious sender and
malicious receiver. We achieve malicious security by designing
efficient zero-knowledge proofs for DH-based statements over elliptic
curves.

\todo{continue, main contributions, implementation}
