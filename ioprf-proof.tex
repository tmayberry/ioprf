\documentclass{article}

\input{macros}

\begin{document}
NOTE: for one-sided security, we use the OT-based solution.
\fixme{Switch to additive notation}

Let there be three generators $g_1,g_2,g_3$ of some DDH group $G$. Nobody
knows the discrete log of one generator $g_i\in\{g_1,g_2,g_3\}$ to
the basis of another generator $g_{j\neq{}i}$.

We will use additive Elgamal encryption with private keys $sk\in\Z_p$
and public keys $pk=g_1^{sk}$. For either $g=g_2$ or $g=g_3$, the
ciphertext $c$ to encrypt $m\in\Z_p$ is
$c=(c[0],c[1])=(g_1^r,pk^r\cdot{}g^m)\leftarrow\enc_{pk,g}(m)$, where
$r\getr\Z_p$.

The sender in $\proto$ knows the $\ioprf$'s secret key
$K=(a_1,\ldots,a_\ell,b_1,\ldots,b_\ell)$ as before. For some input
$x=x_1\ldots{}x_\ell$, we define
$\ioprf_K(x)=g_2^{\prod_{i=1}^{\ell}(a_ix_i+b_i(1-x_i))}$.

\paragraph{Init}
The receiver computes $V_0 \leftarrow\enc_{pk,g_2}(1)$ and
$D_0\leftarrow\enc_{pk,g_2}(1)$, sends them to the sender and proves
that these are encryptions of $1$ with respect to bases $g_2$ and
$g_3$ (see below for details). The sender computes Pedersen
commitments
$(\com_{g_2}(a_1),\ldots,\com_{g_2}(a_\ell),\com_{g_2}(b_1),\ldots,\com_{g_2}(b_\ell))$,
sends them to the receiver, and proves knowledge of plaintexts in ZK
(see below).

\paragraph{Iterative Processing $\ell$ rounds}
In round $i\in\{1,\ldots,\ell\}$, for sender's input bit $x_i$:
\begin{enumerate}
\item {\bf Shuffling:}
\begin{enumerate}
\item   For input bit $x_i$, the receiver computes
  Pedersen commitment $\com_{g_2}(x_i)$ and proves knowledge of $x_i$
  (see below). Similarly, the receiver computes $\com_{g_2}(1-x_i)$
  and proves knowledge of $1-x_i$. Finally, the receiver proves that
  the sum of plaintexts behind $\com_{g_2}(x_i)$ and
  $\com_{g_2}(1-x_i)$ equals $1$ (see below).


\item  The receiver chooses $r\getr\Z_p$ and computes Elgamal ciphertexts
  \begin{align*}
    &c_i=(g_1^r\cdot{}V_{i-1}[0]^{x_i},g_1^{r}\cdot{}V_{i-1}[1]^{x_i})
    \\&c'_i=(g_1^{r'}\cdot{}V_{i-1}[0]^{1-x_i},g_1^{r'}\cdot{}V_{i-1}[1]^{1-x_i})
    \\&d_i=(g_1^{r''}\cdot{}D_{i-1}[0]^{x_i},g_1^{r''}\cdot{}D_{i-1}[1]^{x_i})
    \\&d'_i=(g_1^{r'''}\cdot{}D_{i-1}[0]^{1-x_i},g_1^{r'''}\cdot{}D_{i-1}[1]^{1-x_i})%\text{ and}
  \end{align*}
  and sends $(c_i,c'_i,d_i,d'_i,R_i,S_i)$ to the sender.

  \item The receiver proves correctness of the above computations in
    ZK. Specifically, $(c_i,c'_i,d_i,d'_i)$ result from correct
    exponentiation with $x_i$ (or $1-x_i$) from $\com_{g_2}(x_i)$ (or
    $\com_{g_2}(1-x_i)$), and multiplication with a random power of
    $g_1$, i.e., re-randomization (homomorphic addition of encryption
    of $0$). Similarly, the receiver shows that ciphertexts $R_i$ and
    $S_i$ are correct additions.

    See below for technical details.

    Both parties can now compute
    \begin{align*}&R_i=(c_i[0]\cdot{}d'_i[0],c_i[1]\cdot{}d'_i[1])
    \\&S_i=(c'_i[0]\cdot{}d_i[0],c'_i[1]\cdot{}d_i[1]).
    \end{align*}
   
  \end{enumerate}

\item {\bf PRF:} The sender computes Elgamal ciphertexts
  \begin{align*}
&X_i=(R_i[0]^{a_i},R_i[1]^{a_i})
\\&Y_i=(S_i[0]^{b_i},S_i[1]^{b_i}),
  \end{align*}
sends $(X_i,Y_i)$ to the receiver and proves correct exponentiation
(multiplication of plaintexts) in ZK (see below).
\end{enumerate}
After $\ell$ rounds, the receiver computes
$\ioprf_K(x)=\frac{X_\ell[1]}{X_{\ell}^{sk}}$.

\section{Tools}
\subsection{Pedersen Commitments}
A Pedersen commitment $\com_{g}(m)$ to message $m$ is defined as
$\com_{g}(m)=g_1^r\cdot{}g^m$, where $r\getr\Z_p$, and $g\neq{}g_1$ is
a generator of our DDH group of order $p$.

To open $\com_{g}(m)$, $(m,r)$ is revealed.

\paragraph{Witness Extraction}
Pedersen commitments are trapdoor commitments and allow witness
extraction in Sigma-based ZK proofs as follows.

Before starting the actual ZK proof by the first message from the
prover to the verifier, we send the following two messages:
\begin{enumerate}
\item Prover $P$ sends to verifier $V$: $g=g_1^\rho$ for random
  $\rho\getr\Z_p$. Verifier $V$ will use this $g$ for the computation
  of their commitment.
  \item $V$ computes and sends back commitment $\com_g(e)$ for their
    challenge $e\in\Z_p$.
\end{enumerate}

The ZK proof then continues as usual with the difference that $V$
opens $e$ as their challenge together with randomness $r$ used to
compute the commitment, and $P$ verifies whether $(e,r)$ match
$\com_g(e)$.  After $P$ has sent their final message, $P$ also reveals
$\rho$ to $V$. Only if both is correct, the last ZK proof message
matches  challenge $e$, and $\rho$ matches $g=g_1^\rho$, $V$ accepts.

This setup enables a simulator $\myS$ to extract the witness from
$P$. After receiving trapdoor $\rho$ from $V$, $\myS$ rewinds $P$ until
after the point were $V$ sends $\com_g(e)$ to $P$. Knowing trapdoor
$\rho$, $\myS$ can open $\com_g(e)$ to any $e'\neq{}e$ they want by
solving $r+\rho\cdot{}e=r'+\rho\cdot{}e'$ for $r'$, i.e., they compute
$r'=r+\rho\cdot{}(e-e')$. Running two executions of the ZK proof with the
same input and messages from $P$, but different challenges extracts
the witness of the ZK proof. Details on which $e$ to send in each
execution depend on the exact Sigma ZK proof, but are typically
obvious. We will show an example later.

\paragraph{Prove of Knowledge of Plaintext}
For $\com_{g}(m)=g_1^r\cdot{}g^m$,  prover $P$ can prove that they know
$m$.

\begin{enumerate}
\item $P$ sends $t=g_1^{\rho_1}\cdot{}g^{\rho_2}$ for
  $\rho_1,\rho_2\getr\Z_p$ to $V$.
\item $V$ sends $e\getr\Z_p$ to $P$.
  \item $P$ sends $s_1=\rho_1+e\cdot{}r$ and $s_2=\rho_2+e\cdot{}m$ to
    $V$.
    \item $V$ checks whether $g_1^{s_1}\cdot{}g^{s_2}\sr\com_{g}(m)^e\cdot{}t$.
\end{enumerate}


\subsection{ZK Proofs for Exponents}
\paragraph{DLOG equivalence/DDH tuple/Proof of Encryption of $0$}
You can prove that tuple $(a=g_1,b=g_1^r,c=g_1^x,d=g_1^{xr})$ is a DDH
tuple, i.e., you show that $\log_{a}{b}=\log_c{d}$.

\begin{enumerate}
\item $P$ sends $(t_1=a^{\rho},t_2=c^{\rho})$ for $\rho\getr\Z_p$ to $V$.
  \item $V$ sends $e\getr\Z_p$ to $V$.
  \item $P$ sends $s=\rho+e\cdot{}r$ to $V$.
    \item $V$ accepts if $a^s=b^e\cdot{}t_1$ and $c^s=d^e\cdot{}t_2$.
\end{enumerate}

Observe that this technique also proves that an encryption
$c=(c[0],c[1])=(g_1^r,pk^r\cdot{}g)\leftarrow\enc_{pk,g}(0)$ is an
encryption of $0$ (with respect to base $g$), as $(g_1,c[0],pk,c[1])$
is a DDH tuple.

\paragraph{Plaintext Equivalence}
Let $c_1=(c_1[0],c_1[1],)=(g_1^{r_1},pk^{r_1}\cdot{}g^m)$ and
$c_2=(c_2[0],c_2[1],)=(g_1^{r_2},pk^{r_2}\cdot{}g^m)$ be two
encryptions from $\enc_{pk,g}(m)$. To prove plaintext equivalence of
these two ciphertexts, the prover shows that
$(g_1,\frac{c_1[0]}{c_2[0]},pk,\frac{c_1[1]}{c_2[1]})$ is a DDH tuple.

To prove that some ciphertext $c_1$ encrypts a plaintext $m$ with
respect to base $g$, a simple trick for the prover is to compute
another encryption $c_2$ of $m$ with respect to base $g$, show
plaintext equivalence, and then open randomness of $c_2$.

\subsection{Arithmetics with Pedersen Commitments}
We can do simple arithmetics on Pedersen Commitments.
\begin{itemize}
\item Addition: given $\com_g(a)$ and $\com_g(b)$, everybody can
  compute and thus verify commitment
  $\com_g(c)=\com_g(a)\cdot{}\com_g(b)$ which commits to
  $c=a+b$. Obviously, no party than the one originally computing
  $\com_g(a)$ and $\com_g(b)$ can open $\com_g(c)$, but all parties
  know that $\com_g(c)$ is a commitment to $c=a+b$
  
\item Multiplication: a party committing
  \begin{align*}
  \com_g(a)=g_1^{r_a}\cdot{}g^a, \com_g(b)=g_1^{r_b}\cdot{}g^b,
  \com_g(c)=g_1^{r_c}\cdot{}g^{a\cdot{}b}
  \end{align*}
  can prove in ZK that
  $\com_g(c)$ commits to the product of the messages committed in
  $\com_g(a)$ and $\com_g(b)$.

  The trick is to rewrite
  $\com_g(c)=g_1^{r_c-a\cdot{}r_b}\cdot\com_g(b)^{a}$ and then prove
  that all commitments are well formed, and $\com_g(c)$ uses the same
  exponent $a$ as $\com_g(a)$, but with basis $\com_g(b)$ instead of
  $g$. Specifically,
  \begin{enumerate}
  \item $P$ computes and sends
    \begin{align*}
      t_1=g_1^{\rho_1}\cdot{}g^{\rho_2},
      t_2=g_1^{\rho_3}\cdot{}g^{\rho_4},
      t_3=g_1^{\rho_5}\cdot{}\com_g(b)^{\rho_2}
      \end{align*}
      for $\rho_i\getr\Z_p$. Observe that the same randomness $\rho_2$
      is used for the same witness $a$.
    \item $V$ replies by sending challenge $e\getr\Z_p$.
    \item $P$ sends
      \begin{align*}
        s_1&=\rho_1+e\cdot{}r_a,s_2=\rho_2+e\cdot{}a,s_3=\rho_3+e\cdot{}r_b,s_4=\rho_4+e\cdot{}b,\\s_5&=\rho_5+e\cdot{}(r_c-a\cdot{}r_b).
        \end{align*}
    \item $V$ checks
      \begin{align*}
        g_1^{s_1}\cdot{}g^{s_2}\sr{}\com_g(a)^e, g_1^{s_3}\cdot{}g^{s_4}\sr{}\com_g(b)^e, g_1^{s_5}\cdot{}\com_g(b)^{s_2}\sr{}\com_g(c)^e\cdot{}t_3.
        \end{align*}
\end{enumerate}

  \item Multiplication with group elements: given two elements $(A,B)$
    of our DDH group, such as an Elgamal ciphertext tuple, a party can
    commit to a value $x$ with $\com_g(x) =g_1^r\cdot{}g^x$ and prove
    that $(C=A^x,D=B^X)$ are the result of exponentiation with $x$.
    \begin{enumerate}
      \item $P$ sends $t_1=A^{\rho_1},t_2=B^{\rho_1},
        t_3=g_1^{\rho_2}\cdot{}g^{\rho_1}$, for randomly chosen
        $\rho_i\getr\Z_p$, to $V$.

      \item $V$ sends challenge $e\getr\Z_p$.

      \item $P$ sends $s_1=\rho_1+e\cdot{}x,s_2=\rho_2+e\cdot{}r$.
        \item $V$ checks $A^{s_1}\sr{}C^e\cdot{}t_1$,
          $B^{s_1}\sr{}D^e\cdot{}t_2$, and
          $g_1^{s_2}\cdot{}g^{s_1}\sr{}\com_g(x)^e\cdot{}t_3$.
          
      \end{enumerate}   

\item Simple combinations: you can efficiently combine arithmetic
  operations. For example, the following proves correctness of
  exponentiation of two group elements with a committed value and
  multiplying both with $g_1^{r'}$. So, you can prove correct scalar
  multiplication of an Elgamal ciphertext by a previously committed
  value and subsequent re-randomization of the result (addition of
  Elgamal encryption of $0$).

Given two group elements $(A,B)$ and commitment $\com_g(x)
=g_1^{r}\cdot{}g^x$, prove correctness that
$(C=g_1^{r'}\cdot{}A^x,D=g_1^{r'}\cdot{}B^X)$ are the result of
exponentiation with $x$ and multiplying with some $r'\getr\Z_p$ known
to the prover.

\begin{enumerate}
  \item $P$ sends $t_1=g_1^{\rho_1}\cdot{}A^{\rho_2},t_2=g_1^{\rho_1}\cdot{}B^{\rho_2},t_3=g_1^{\rho_3}\cdot{}g^{\rho_2}$ to $V$.
  \item $V$ sends $e\getr\Z_p$ to $P$.
    \item $P$ sends $s_1=\rho_1+e\cdot{}r'$, $s_2=\rho_2+e\cdot{}x$,
      and $s_3=\rho_3+e\cdot{}r$ to $V$.
\item $V$ check whether $g_1^{s_1}\cdot{}A^{s_2}\sr{}C^e\cdot{}t_1$,
  $g_1^{s_1}\cdot{}B^{s_2}\sr{}D^e\cdot{}t_2$, and
  $g_1^{s_3}\cdot{}g^{s_2}\sr{}\com_g(x)^e\cdot{}t_3$.
\end{enumerate}

\item Sum of plaintexts equals $1$: for commitments
  $\com_{g}(x)=g_1^r\cdot{}g^x$ and
  $\com_{g}(1-x)=g_1^{r'}\cdot{}g^{1-x}$, the prover can show that the sum of
  plaintexts equals $1$.

  \begin{enumerate}
  \item $P$ and $V$ compute
    $\com_{g}(1)=\com_{g}(x)\cdot{}\com_{g}(1-x)=g_1^{r+r'}\cdot{}g$.
\item $P$ proves that $\com_{g}(1)$ is a commitment to $1$ (see
  above).
  \end{enumerate}
\end{itemize}


\newpage
\section{Old}
Let there be 2 generators $G_1$ and $G_2$ of some DDH group. The
sender has secret key $K=(a_1,\ldots,a_\ell,b_1,\ldots,b_\ell)$ as
before. For some input $x=x_1\ldots{}x_\ell$, we define
$\ioprf_K(x)=\prod_{i=1}^{\ell}(a_ix_i+b_i(1-x_i))\cdot{}G_1$.

\paragraph{Init}
The receiver sets $V_0 = G_1$ and $D_0 = G_2$, commits to $V_0$ and
$D_0$, but also sends randomness used for commitments to the
sender. Therewith, the sender knows that the commitments are really
containing $G_1$ and $G_2$. The sender commits to $a_i,b_i$.

\paragraph{Iterative Processing $\ell$ rounds}
In round $i\in\{1,\ldots,\ell\}$, for sender's input bit $x_i$:

\begin{enumerate}
\item {\bf Blinding:} The receiver computes $V'_i = t_i\cdot{}V_{i-1}$ and
  $D'_i=t_i \cdot D_{i-1}$ for a randomly chosen $t_i$. The receiver
  commits to $t_i$, $V'_i$, and $D'_i$ and proves the following two
  Groth-Sahai (GS) equations to the sender
\begin{align}
  \myO &= t_i \cdot V_{i-1} - 1 \cdot V'_i \\
  \myO &= t_i \cdot D_{i-1} - 1\cdot{}D'_i
\end{align}

      (Constants are $0$ and $-1$, and variables are $t_i, V_i, D_i,
      V'_i, D'_i$.)

      These two equations prove correctness of commitments $V'_i$ and
      $D'_i$. Observe that the receiver does not send $V'_i,D'_i$ to
      the sender, but only their commitments.

    \item {\bf Shuffling:} For input bit $x_i$, the receiver computes
      \begin{align}
        R_i = x_i \cdot V'_i + (1-x_i) \cdot D'_i
        \\S_i = (1-x_i) \cdot V'_i + x_i \cdot D'_i.
      \end{align}

      The receiver
      commits to $x_i$ (and has to prove that $x_i$ is either a 0 or
      1, see below). The receiver sends both $R_i$ and $S_i$ proves them as GS equations.

      (Constants are $R_i,S_i$, and
      the -1 (there are some tricks), and variables are $x_i, V'_i$, and
      $D'_i$.)

      Therewith, the receiver has given a random shuffle (depending on
      $x_i$) of $V_i$ and $D_i$ to the sender. The sender does not
      know which of $R_i$ and $S_i$ is $V_i$ or $D_i$.
      
    \item The sender computes \begin{align}
                                X_i &= a_i \cdot R_i\\
                                Y_i &= b_i \cdot S_i
                                \end{align}

                                and sends $X_i,Y_i$ back and proves
                                them with two GS equations.

                              \item The receiver commits to $t_i^{-1}$
                                and proves $t_i^{-1}\cdot{}t_i = 1$. This is a quadratic equation.


                              \item The receiver computes
\begin{align}
  V_{i} = t_i^{-1} \cdot X_i\\
  D_{i} = t_i^{-1} \cdot Y_i,
\end{align}
and proves them.


\end{enumerate}

Proving that $x_i$ is a bit is a quadratic equation:
$x_i \cdot (1-x_i) = 0$.


It is important that $G_1$ and $G_2$ are random. Specifically, the
receiver does not know the elliptic curve DLOG of $G_2$ to basis
$G_1$, i.e., $\log_{G_1}{G_2}$. Both $G_1$ and $G_2$ could be part of
the CRS.

\end{document}
