\subsection{DH-based $\proto$ Construction}
NOTE: for one-sided security, we use the OT-based solution.
\fixme{Switch to additive notation}


\subsubsection{Preliminaries}
Let there be two generators $g_1,g_2$ of prime order $p$ DDH group
$\G$. Nobody knows the discrete log of one generator $g_i$ to the
basis of the other generator $g_{j\neq{}i}$.

\paragraph{Elgamal Encryption}
We will use additive Elgamal encryption with private keys $sk\in\Z_p$
and public keys $pk=g_1^{sk}$. Ciphertext $c$ to encrypt $m\in\Z_p$ is
$c=(c[0],c[1])=(g_1^r,pk^r\cdot{}g_2^m)\leftarrow\enc_{pk}(m)$, where
$r\getr\Z_p$.

\paragraph{Pedersen Commitments}
A Pedersen commitment $\com_{g}(m)\in\G$ to message $m\in\Z_p$ is defined as
$\com_{g}(m)=g_1^r\cdot{}g^m$, where $r\getr\Z_p$, and $g\neq{}g_1$ is
a generator of $\G$.  To open $\com_{g}(m)$, reveal $(m,r)$.


\subsubsection{$\proto$ Initialization}
The sender in $\proto$ knows the $\iprf$'s secret key
$K=(\alpha_1,\ldots,\alpha_\ell,\beta_1,\ldots,\beta_\ell)$ as before. For some input
string $x=(x_1\ldots{}x_\ell)$, we define the output of $\proto$ for
the receiver as
$\iprf_K(x)=g_2^{\prod_{i=1}^{\ell}(\alpha_i{}x_i+\beta_i(1-x_i))}$.

The receiver computes $V_0 \leftarrow\enc_{pk}(1)$ and
$D_0\leftarrow\enc_{pk}(0)$, sends them to the sender and proves that
these are encryptions of $1$ and $0$ (see \S\ref{poe} below). The
sender computes Pedersen commitments
$(\com_{g_2}(\alpha_1),\ldots,\com_{g_2}(\alpha_\ell),\com_{g_2}(\beta_1),\ldots,\com_{g_2}(\beta_\ell))$,
sends them to the receiver, and proves knowledge of plaintexts in ZK
(see \S\ref{pokop}).

\subsubsection{$\proto$ Iterative Processing in $\ell$ Rounds}
In round $i\in\{1,\ldots,\ell\}$, for sender's input bit $x_i$:
\begin{enumerate}
\item {\bf Shuffling:}
\begin{enumerate}
\item For input bit $x_i$, the receiver computes Pedersen commitment
  $\com_{g_2}(x_i)$ and proves that $x_i\in\{0,1\}$ (see
  \S\ref{pobit}). Similarly, the receiver computes $\com_{g_2}(1-x_i)$
  and proves that $(1-x_i)\in\{0,1\}$ (see \S\ref{pobit}). Finally,
  the receiver proves that the sum of plaintexts behind
  $\com_{g_2}(x_i)$ and $\com_{g_2}(1-x_i)$ equals $1$ (see
  \S\ref{pkseo}).


\item  The receiver chooses $r,r',r'',r'''\getr\Z_p$ and computes Elgamal ciphertexts
  \begin{align*}
    &c_i=(g_1^r\cdot{}V_{i-1}[0]^{x_i},pk^{r}\cdot{}V_{i-1}[1]^{x_i})
    \\&c'_i=(g_1^{r'}\cdot{}V_{i-1}[0]^{1-x_i},pk^{r'}\cdot{}V_{i-1}[1]^{1-x_i})
    \\&d_i=(g_1^{r''}\cdot{}D_{i-1}[0]^{x_i},pk^{r''}\cdot{}D_{i-1}[1]^{x_i})
    \\&d'_i=(g_1^{r'''}\cdot{}D_{i-1}[0]^{1-x_i},pk^{r'''}\cdot{}D_{i-1}[1]^{1-x_i})%\text{ and}
  \end{align*}
  and sends $(c_i,c'_i,d_i,d'_i)$ to the sender.

\item The receiver proves correctness of the above computations in
  ZK. Specifically, $(c_i,c'_i,d_i,d'_i)$ result from correct
  exponentiation with $x_i$ (or $1-x_i$) from $\com_{g_2}(x_i)$ (or
  $\com_{g_2}(1-x_i)$), and multiplication with a random power of
  $g_1$ and $pk$, i.e., re-randomization (homomorphic addition of
  encryption of $0$).  See \S\ref{pshuffle} below for details.

   Both parties can now compute
    \begin{align*}&T_i=(c_i[0]\cdot{}d'_i[0],c_i[1]\cdot{}d'_i[1])
    \\&U_i=(c'_i[0]\cdot{}d_i[0],c'_i[1]\cdot{}d_i[1]).
    \end{align*}
   
  \end{enumerate}

\item {\bf PRF:} The sender computes Elgamal ciphertexts
  \begin{align*}
&X_i=(T_i[0]^{\alpha_i},T_i[1]^{\alpha_i})
\\&Y_i=(U_i[0]^{\beta_i},U_i[1]^{\beta_i}),
  \end{align*}
sends $(X_i,Y_i)$ to the receiver and proves correct exponentiation
(multiplication of plaintexts) in ZK (see \S\ref{pomult}).

\item {\bf Shuffling back:}
  For $r,r',r'',r'''\getr\Z_p$, the receiver computes
  \begin{align*}
    P_i&=(g_1^r\cdot{}X_i[0]^{x_i},pk^r\cdot{}X_i[1]^{x_i})
    \\P'_i&=(g_1^{r'}\cdot{}X_i[0]^{1-x_i},pk^{r'}\cdot{}X_i[1]^{1-x_i})
   \\Q_i&=(g_1^{r''}\cdot{}Y_i[0]^{x_i},pk^{r''}\cdot{}Y_i[1]^{x_i})
   \\Q'_i&=(g_1^{r'''}\cdot{}Y_i[0]^{1-x_i},pk^{r'''}\cdot{}Y_i[1]^{1-x_i})
  \end{align*} 
  and sends $(P_i,P'_i,Q_i,Q'_i)$ together with ZK proofs of correct
  computation (see \S\ref{pshuffle}) to the sender.

  Both sender and receiver compute
  $V_i=(P_i[0]\cdot{}Q'_i[0],P_i[1]\cdot{}Q'_i[1])$ and
  $D_i=(P'_i[0]\cdot{}Q_i[0],P'_i[1]\cdot{}Q_i[1])$.
  
\end{enumerate}

After $\ell$ rounds, the receiver computes output
$\iprf_K(x)=\frac{V_\ell[1]}{V_{\ell}[0]^{sk}}$.


\subsection{Security Analysis}
 
\todo{We prove in the hybrid model and make use of several ZK hybrids
  introduced below. Description is HVZK for ease of reading, but we
  convert to malicious verifier using CRS model introduced below,
  too. For ease of reading, we present ZK proofs, but convert to ZKPoK
  using a generic transformation introduced below, too.}

\subsubsection{Witness Extraction for Pedersen Commitments}
Recall that a three-move ZK proof comprises messages $(t,e,s)$, where
first message $t$ is a commitment from $P$ sent to $V$, $e$ is $V$'s
challenge sent to $P$, and $s$ is the final message sent from $P$ to
$V$.

Pedersen commitments are trapdoor commitments which means that a party
knowing a trapdoor $\rho$ can open a commitment $\com_g(\cdot)$ to any
plaintext they want (equivocable).  We use this property for witness
extraction in three-move ZK proofs as follows.

Before starting the actual ZK proof by the first message $a$ from the
prover to the verifier, we send the following two messages:
\begin{enumerate}
\item Prover $P$ sends to verifier $V$: $g=g_1^\rho$ for random
  $\rho\getr\Z_p$. 
  \item Verifier $V$ will use this $g$ for the computation of the
    commitment to challenge $e$.  That is, $V$ computes and sends back
    commitment $\com_g(e)$ for their challenge $e\in\Z_p$.
\end{enumerate}

The ZK proof then continues as usual with the difference that $V$
opens $e$ as their challenge together with randomness $r$ used to
compute the commitment, and $P$ verifies whether $(e,r)$ match
$\com_g(e)$.  After $P$ has sent final message $s$, $P$ also
reveals $\rho$ to $V$. Only if both is correct, the last ZK proof
message $s$ matches $P$'s commitment $t$ and challenge $e$, and $\rho$
matches $g=g_1^\rho$, $V$ accepts.

This setup enables a simulator $\myS$ to extract the witness from
$P$. After receiving trapdoor $\rho$ from $V$, $\myS$ rewinds $P$ until
after the point were $V$ sends $\com_g(e)$ to $P$. Knowing trapdoor
$\rho$, $\myS$ can open $\com_g(e)$ to any $e'\neq{}e$ they want by
solving $r+\rho\cdot{}e=r'+\rho\cdot{}e'$ for $r'$, i.e., they compute
$r'=r+\rho\cdot{}(e-e')$. Running two executions of the ZK proof with the
same input and messages from $P$, but different challenges extracts
the witness of the ZK proof. Details on which $e$ to send in each
execution depend on the exact three-move ZK proof, but are typically
obvious. We will show an example later.

\subsubsection{Zero Knowledge (instead of Honest-Verifier ZK)}
\fixme{We cannot use Fiat-Shamir transform and replace $e$, as we
  Pedersen commitments for witness extraction.}

To ease readability, all ZK proofs here are described in their
honest-verifier ZK version. To make these proofs zero-knowledge
instead, we replace first message $t$ of the regular three-move
protocol by a Pedersen commitment $\com_{g_r}(t)$ from prover
$P$. Here, the commitment uses generator $g_r=H(r)$ for a random $r$
chosen by $V$. The protocol then continues with $V$ sending their
challenge $e$, and finally $P$ sending last message $z$ of the regular
protocol together with opening commitment $\com_{g_r}(t)$. Verifier
$V$ accepts, if the commitment matches and $s$ of the regular protocol
matches $e$.

In the Random-Oracle model, this technique allows a simulator $\myS$
to learn $e$ before sending first message $t$ of the three-move
protocol.  More specifically, $\myS$ sets up a random oracle $H$ to
map input strings to elements of the DDH group as follows. $\myS$ sets
up an initially empty table $T$ which will store tuples
$(r,\rho_r,g_r)$. For a query $H(r)$, $\myS$ will look up whether an
entry with $r$ already exists in $T$. If yes, then $\myS$ returns
$g_r$ to the caller. If not, $\myS$ chooses $\rho_r\getr\Z_p$, stores
$(r,\rho_r,g_r=g_1^{\rho_r})$ in $T$, and returns $g_r$ to the caller.

So, before $\myS$ sends any commitment, $V$ starts by sending
$r\getr\Z_p$, and $\myS$'s commitment will be computed with respect to
some $g_r$ where $\myS$ knows trapdoor $\rho_r$.  Instead of
commitment $\com_{g'}(t)$, $\myS$ then commits at the beginning to
some arbitrary $r'$ by sending $\com_{g_r=H(r)}(r')$. As soon as
$\myS$ has received $e$, they can fake last message $s$ of the
three-move protocol and open the initial commitment accordingly.  See
\citet{crs} for details.

Observe that witness extraction and zero knowledge can be combined in
the natural way: first, $P$ sends $g=g_1^{\rho_1}$ to $V$ who replies
with $\com_g(e)$ and $r\getr\Z_p$. Then, $P$ sends commitment
$\com_{H(r)}(t)$, and $V$ opens $\com_g(e)$.  Finally $P$ opens
$\com_{H(r)}(t)$ to reveal $t$, and sends last message $s$ of the
three-move protocol.


\subsubsection{Proof of Encryption/Commitment to $m$}
\label{poe}

To prove that an encryption
$c=(c[0],c[1])=(g_1^r,pk^r)\leftarrow\enc_{pk}(0)$ is an encryption of
$m=0$, $P$ proves that $(g_1,c[0],pk,c[1])$ is a DDH tuple.  You can
prove that tuple
$(u_1=g_1,u_2=g_1^r,u_3=g_1^{sk},u_4=g_1^{sk\cdot{}r})$ is a DDH tuple
using the \citet{cp92} protocol as follows.

\begin{enumerate}
\item $P$ sends $(t_1=u_1^{\rho},t_2=u_3^{\rho})$ for $\rho\getr\Z_p$ to $V$.
  \item $V$ sends $e\getr\Z_p$ to $P$.
  \item $P$ sends $s=\rho+e\cdot{}r$ to $V$.
    \item $V$ accepts if $u_1^s=u_2^e\cdot{}t_1$ and $u_3^s=u_4^e\cdot{}t_2$.
\end{enumerate}

This proof has an important property.\ignore{ Besides showing that a
  tuple is a DDH tuple, it also shows DLOG equivalence, i.e.,
  $\log_{u_1}{u_2}=\log_{u_3}{u_4}$.} Instead of showing that some
ciphertext encrypts $m=0$, we can easily generalize it to show
encryption of arbitrary $m$. Specifically, we set
$c'[1]=\frac{c[1]}{g_2^m}$ and run the proof for new Elgamal
ciphertext $(c[0],c'[1])$.

Finally, observe that Pedersen commitments are essentially just the
right-hand side $c[1]$ of an Elgamal ciphertext. Thus, to prove a
Pedersen commitment $\com_g(m)$ to $m$, parties divide $\com_g(m)$ by
$g^m$ and run a Schnorr proof for $r$ used in the commitment ($P$
sends $t=g_1^\rho$, $V$ sends $e$, $P$ sends $s=\rho+e\cdot{}r$, and $V$
accepts if $g_1^s\sr\frac{\com_g(m)^e}{g^m}\cdot{}t$.)


\subsubsection{Proof for Knowledge of Plaintext}
\label{pokop}
For $\com_{g}(m)=g_1^r\cdot{}g^m$,  prover $P$ can prove that they know
$m$.

\begin{enumerate}
\item $P$ sends $t=g_1^{\rho_1}\cdot{}g^{\rho_2}$ for
  $\rho_1,\rho_2\getr\Z_p$ to $V$.
\item $V$ sends $e\getr\Z_p$ to $P$.
  \item $P$ sends $s_1=\rho_1+e\cdot{}r$ and $s_2=\rho_2+e\cdot{}m$ to
    $V$.
    \item $V$ checks whether $g_1^{s_1}\cdot{}g^{s_2}\sr\com_{g}(m)^e\cdot{}t$.
\end{enumerate}

\subsubsection{Proof of Plaintext Bit}
\label{pobit}
For a commitment $\com_g(x_i)$, prover $P$ can prove that
$x_i\in\{0,1\}$, i.e., a bit. This is an application of the
\emph{one-out-of-two} (OR) technique~\cite{ooot}. Essentially, $P$
proves that $\com_g(x_i)=g_1^{r}\cdot{}g=c_1$ or
$\com_g(x_i)=g_1^{r'}=c_2$ by proving that they know an $r$ or $r'$
matching $c_1$ or $c_2$. The trick is that $P$ chooses $e_1$ and $e_2$
such that, for the verifier's challenge $e$, we have
$e=e_1+e_2$. Prover $P$ proves knowledge of $r$ for $c_1$ using
challenge $e_1$ and knowledge of $r'$ for $c_2$ using challenge
$e_2$. Thus, $P$ can choose either $e_1$ or $e_2$ before sending their
first message of the ZK proof and cheat in one proof. Without loss of
generality, let $x_i=1$, so $P$ will cheat for the proof of
$c_2$. This works as follows.

\begin{enumerate}
\item $P$ sends $t_1=g_1^\rho\cdot{}g$ and
  $t_2=c_2^{-e_2}\cdot{}g_1^{\rho'}$, for $\rho,\rho'\getr\Z_p$, to
  $V$.
\item $V$ sends $e\getr\Z_p$ to $P$.
  \item $P$ sends $e_1,e_2,s_1=\rho+e_1\cdot{}r$, and $s_2=\rho'$ to $V$.

\item $V$ checks $e\sr{}e_1+e_2$, $g_1^{s_1}\cdot{}g^{e+1}\sr{}c_1^e\cdot{}t_1$ and $g_1^{s_2}\sr{}c_2^e\cdot{}t_2$.
\end{enumerate}



\subsubsection{Proof of Sum of Plaintexts equals $1$}
\label{pkseo}
For commitments $\com_{g}(x)=g_1^r\cdot{}g^x$ and
$\com_{g}(1-x)=g_1^{r'}\cdot{}g^{1-x}$, $P$ can show that the sum of
plaintexts equals $1$.

  \begin{enumerate}
  \item $P$ and $V$ compute
    $\com_{g}(1)=\com_{g}(x)\cdot{}\com_{g}(1-x)=g_1^{r+r'}\cdot{}g$.
\item $P$ proves that $\com_{g}(1)$ is a commitment to $1$ (see
  above).
  \end{enumerate}


  \subsubsection{Proof of correct Shuffle and Re-Encryption}
\label{pshuffle}
  You can
      efficiently prove correctness of arithmetic operations. For
      example, the following proves correctness of exponentiation of
      two elements $(A,B)$ from group $\G$ with a committed value $x$
      and multiplying $A$ by $g_1^{r'}$ and $B$ by $pk^{r'}$. So, you
      can prove correct scalar multiplication of an Elgamal ciphertext
      by a previously committed $x$ and subsequent re-randomization of
      the result (addition of Elgamal encryption of $0$).

      Specifically, given two group elements $(A,B)$ and commitment
      $\com_g(x) =g_1^{r}\cdot{}g^x$, prove correctness that
      $(C=g_1^{r'}\cdot{}A^x,D=pk^{r'}\cdot{}B^x)$ are the result of
      exponentiation with $x$ and multiplying with $g^{r'}$ and
      $pk^{r'}$, $r'\getr\Z_p$, known to the prover.

\begin{enumerate}
  \item $P$ sends $t_1=g_1^{\rho_1}\cdot{}A^{\rho_2},t_2=pk^{\rho_1}\cdot{}B^{\rho_2},t_3=g_1^{\rho_3}\cdot{}g^{\rho_2}$ to $V$.
  \item $V$ sends $e\getr\Z_p$ to $P$.
    \item $P$ sends $s_1=\rho_1+e\cdot{}r'$, $s_2=\rho_2+e\cdot{}x$,
      and $s_3=\rho_3+e\cdot{}r$ to $V$.
\item $V$ check whether $g_1^{s_1}\cdot{}A^{s_2}\sr{}C^e\cdot{}t_1$,
  $pk^{s_1}\cdot{}B^{s_2}\sr{}D^e\cdot{}t_2$, and
  $g_1^{s_3}\cdot{}g^{s_2}\sr{}\com_g(x)^e\cdot{}t_3$.
\end{enumerate}


\subsubsection{Proof of Multiplication with Group Elements}
\label{pomult}
Given two elements $(A,B)$ of our DDH group, such as an Elgamal
ciphertext tuple, a party can commit to a value $x$ with $\com_g(x)
=g_1^r\cdot{}g^x$ and prove that $(C=A^x,D=B^x)$ are the result of
exponentiation with $x$.

\begin{enumerate}
      \item $P$ sends $t_1=A^{\rho_1},t_2=B^{\rho_1},
        t_3=g_1^{\rho_2}\cdot{}g^{\rho_1}$, for randomly chosen
        $\rho_i\getr\Z_p$, to $V$.

      \item $V$ sends challenge $e\getr\Z_p$.

      \item $P$ sends $s_1=\rho_1+e\cdot{}x,s_2=\rho_2+e\cdot{}r$.
        \item $V$ checks $A^{s_1}\sr{}C^e\cdot{}t_1$,
          $B^{s_1}\sr{}D^e\cdot{}t_2$, and
          $g_1^{s_2}\cdot{}g^{s_1}\sr{}\com_g(x)^e\cdot{}t_3$.
          
      \end{enumerate}   

\ignore{
\section{Old ZK Tools}
\subsubsection{ZK Proofs for Exponents}
\paragraph{Proof of Plaintext Equivalence}
Let $c_1=(c_1[0],c_1[1],)=(g_1^{r_1},pk^{r_1}\cdot{}g^m)$ and
$c_2=(c_2[0],c_2[1],)=(g_1^{r_2},pk^{r_2}\cdot{}g^m)$ be two
encryptions from $\enc_{pk}(m)$. To prove plaintext equivalence of
these two ciphertexts, the prover shows that
$(g_1,\frac{c_1[0]}{c_2[0]},pk,\frac{c_1[1]}{c_2[1]})$ is a DDH tuple.

To prove that some ciphertext $c_1$ encrypts a plaintext $m$ with
respect to base $g$, a simple trick for the prover is to compute
another encryption $c_2$ of $m$ with respect to base $g$, show
plaintext equivalence, and then open randomness of $c_2$.

\subsubsection{Proofs for Arithmetic with Pedersen Commitments}
We can do simple arithmetic on Pedersen Commitments.
\begin{itemize}
\item Addition: given $\com_g(a)$ and $\com_g(b)$, everybody can
  compute and thus verify commitment
  $\com_g(c)=\com_g(a)\cdot{}\com_g(b)$ which commits to
  $c=a+b$. Obviously, no other party than the one originally computing
  $\com_g(a)$ and $\com_g(b)$ can open $\com_g(c)$, but all parties
  know that $\com_g(c)$ is a commitment to $c=a+b$
  
\item Multiplication: a party committing
  \begin{align*}
  \com_g(a)=g_1^{r_a}\cdot{}g^a, \com_g(b)=g_1^{r_b}\cdot{}g^b,
  \com_g(c)=g_1^{r_c}\cdot{}g^{a\cdot{}b}
  \end{align*}
  can prove in ZK that
  $\com_g(c)$ commits to the product of the messages committed in
  $\com_g(a)$ and $\com_g(b)$.

  The trick is to rewrite
  $\com_g(c)=g_1^{r_c-a\cdot{}r_b}\cdot\com_g(b)^{a}$ and then prove
  that all commitments are well formed, and $\com_g(c)$ uses the same
  exponent $a$ as $\com_g(a)$, but with basis $\com_g(b)$ instead of
  $g$. Specifically,
  \begin{enumerate}
  \item $P$ computes and sends
    \begin{align*}
      t_1=g_1^{\rho_1}\cdot{}g^{\rho_2},
      t_2=g_1^{\rho_3}\cdot{}g^{\rho_4},
      t_3=g_1^{\rho_5}\cdot{}\com_g(b)^{\rho_2}
      \end{align*}
      for $\rho_i\getr\Z_p$. Observe that the same randomness $\rho_2$
      is used for the same witness $a$.
    \item $V$ replies by sending challenge $e\getr\Z_p$.
    \item $P$ sends
      \begin{align*}
        s_1&=\rho_1+e\cdot{}r_a,s_2=\rho_2+e\cdot{}a,s_3=\rho_3+e\cdot{}r_b,s_4=\rho_4+e\cdot{}b,\\s_5&=\rho_5+e\cdot{}(r_c-a\cdot{}r_b).
        \end{align*}
    \item $V$ checks
      \begin{align*}
        g_1^{s_1}\cdot{}g^{s_2}\sr{}\com_g(a)^e, g_1^{s_3}\cdot{}g^{s_4}\sr{}\com_g(b)^e, g_1^{s_5}\cdot{}\com_g(b)^{s_2}\sr{}\com_g(c)^e\cdot{}t_3.
        \end{align*}
\end{enumerate}

\end{itemize}
}%ignore




\ignore{
\newpage
\section{Old}
Let there be 2 generators $G_1$ and $G_2$ of some DDH group. The
sender has secret key $K=(a_1,\ldots,a_\ell,b_1,\ldots,b_\ell)$ as
before. For some input $x=x_1\ldots{}x_\ell$, we define
$\ioprf_K(x)=\prod_{i=1}^{\ell}(a_ix_i+b_i(1-x_i))\cdot{}G_1$.

\paragraph{Init}
The receiver sets $V_0 = G_1$ and $D_0 = G_2$, commits to $V_0$ and
$D_0$, but also sends randomness used for commitments to the
sender. Therewith, the sender knows that the commitments are really
containing $G_1$ and $G_2$. The sender commits to $a_i,b_i$.

\paragraph{Iterative Processing $\ell$ rounds}
In round $i\in\{1,\ldots,\ell\}$, for sender's input bit $x_i$:

\begin{enumerate}
\item {\bf Blinding:} The receiver computes $V'_i = t_i\cdot{}V_{i-1}$ and
  $D'_i=t_i \cdot D_{i-1}$ for a randomly chosen $t_i$. The receiver
  commits to $t_i$, $V'_i$, and $D'_i$ and proves the following two
  Groth-Sahai (GS) equations to the sender
\begin{align}
  \myO &= t_i \cdot V_{i-1} - 1 \cdot V'_i \\
  \myO &= t_i \cdot D_{i-1} - 1\cdot{}D'_i
\end{align}

      (Constants are $0$ and $-1$, and variables are $t_i, V_i, D_i,
      V'_i, D'_i$.)

      These two equations prove correctness of commitments $V'_i$ and
      $D'_i$. Observe that the receiver does not send $V'_i,D'_i$ to
      the sender, but only their commitments.

    \item {\bf Shuffling:} For input bit $x_i$, the receiver computes
      \begin{align}
        R_i = x_i \cdot V'_i + (1-x_i) \cdot D'_i
        \\S_i = (1-x_i) \cdot V'_i + x_i \cdot D'_i.
      \end{align}

      The receiver
      commits to $x_i$ (and has to prove that $x_i$ is either a 0 or
      1, see below). The receiver sends both $R_i$ and $S_i$ proves them as GS equations.

      (Constants are $R_i,S_i$, and
      the -1 (there are some tricks), and variables are $x_i, V'_i$, and
      $D'_i$.)

      Therewith, the receiver has given a random shuffle (depending on
      $x_i$) of $V_i$ and $D_i$ to the sender. The sender does not
      know which of $R_i$ and $S_i$ is $V_i$ or $D_i$.
      
    \item The sender computes \begin{align}
                                X_i &= a_i \cdot R_i\\
                                Y_i &= b_i \cdot S_i
                                \end{align}

                                and sends $X_i,Y_i$ back and proves
                                them with two GS equations.

                              \item The receiver commits to $t_i^{-1}$
                                and proves $t_i^{-1}\cdot{}t_i = 1$. This is a quadratic equation.


                              \item The receiver computes
\begin{align}
  V_{i} = t_i^{-1} \cdot X_i\\
  D_{i} = t_i^{-1} \cdot Y_i,
\end{align}
and proves them.


\end{enumerate}

Proving that $x_i$ is a bit is a quadratic equation:
$x_i \cdot (1-x_i) = 0$.


It is important that $G_1$ and $G_2$ are random. Specifically, the
receiver does not know the elliptic curve DLOG of $G_2$ to basis
$G_1$, i.e., $\log_{G_1}{G_2}$. Both $G_1$ and $G_2$ could be part of
the CRS.
}%ignore
