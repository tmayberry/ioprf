\documentclass{article}

\input{macros}

\begin{document}
\section{Ideal Functionality $\myF$}
We describe a reactive ideal functionality $\myF$.  The database sends
their input, keys $K_\myroot,K_0,K_1,\ldots,K_{1\ldots{}1}$, all $N$
keys of the key tree, to $\myF$, and the reader sends empty bit string
$\epsilon$. In return, $\myF$ sends $K_\myroot$ to the reader, and
nothing to the database.  The internal state $s$ of $\myF$ is
initialized to the empty bit string $\epsilon$.

Then, the RFID reader and $\myF$ additionally interact in a total of
$\ell$ rounds. In round $i$, let the internal state be bit string
$s=\beta_1\ldots{}\beta_{i-1}$. The reader sends bit $\beta_i$, and
$\myF$ responds with $K_{\beta_1\ldots\beta_{i}}$ and updates its
state to $s=\beta_1\ldots\beta_{i}$.


\section{Proof}
N.B.: For the proof, we assume that the RFID reader knows
$\trace=(r,H(r,
K_\myroot,x_1),\ldots,H(r,K_{x_1\ldots{}x_{\ell-1}},x_{\ell}),H(r,K_{x_1\ldots{}x_\ell}))$
from a valid tag $x$.

Public information: the total number $N$ of tags in the system (leaves
in tree $T$, $\lambda$ security parameter.

\begin{proof}[Draft]
  \begin{itemize}

  \item Simulator $\myS$ begins by preparing an initially empty
    key-value table to implement a standard random oracle
    functionality $H$. Whenever any party calls $H(\cdot)$ with some
    input $k$, this functionality will check whether $k$ is already in
    the table and responds with $v$. Otherwise, $H$ generates a random
    string $v$ of length $\lambda$, sends $v$ back to the caller, and
    places $(k,v)$ in the table.

  \item Adversary $\A$ sends $v'$ to $\myS$ (\fixme{or extractable
      commitment}). $\myS$ looks up $v'$ in its internal table and
    thus extracts $k'=\trace'$ such that $v'=H(\trace)$.

  \item $\myS$ forwards $\trace$ to $\myF$ and gets back reply
    $\beta_1\ldots\beta_\ell=\mathsf{ValidPrefix(\trace')}$.
    
  \item  $\myS$ begins by building their own binary key tree
    $T'$ with $n$ leaves.  For each node, $\myS$ randomly chooses a
    bit string of length $\lambda$ and writes into the node.  Using
    the same notation as with the database's tree $T$, each node
    $\beta_1\ldots{}\beta_i$ in $T'$ thus stores a random bit string
    $K'_{\beta_1\ldots{}\beta_i}$, and the root stores random bit
    string $K'_\myroot$.



    
    \end{itemize}
\end{proof}


\end{document}